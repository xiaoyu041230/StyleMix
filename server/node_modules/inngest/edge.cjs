const require_InngestCommHandler = require('./components/InngestCommHandler.cjs');
const require_InngestDurableEndpointProxy = require('./components/InngestDurableEndpointProxy.cjs');
const require_InngestEndpointAdapter = require('./components/InngestEndpointAdapter.cjs');

//#region src/edge.ts
/**
* The name of the framework, used to identify the framework in Inngest
* dashboards and during testing.
*/
const frameworkName = "edge";
const commHandler = (options, syncOptions) => {
	return new require_InngestCommHandler.InngestCommHandler({
		frameworkName,
		fetch: fetch.bind(globalThis),
		...options,
		syncOptions,
		handler: (req) => {
			return {
				body: () => req.text(),
				headers: (key) => req.headers.get(key),
				method: () => req.method,
				url: () => new URL(req.url, `https://${req.headers.get("host") || ""}`),
				transformResponse: ({ body, status, headers }) => {
					return new Response(body, {
						status,
						headers
					});
				},
				experimentalTransformSyncResponse: async (data) => {
					const res = data;
					const headers = {};
					res.headers.forEach((v, k) => {
						headers[k] = v;
					});
					return {
						headers,
						status: res.status,
						body: await res.clone().text()
					};
				}
			};
		}
	});
};
/**
* In an edge runtime, serve and register any declared functions with Inngest,
* making them available to be triggered by events.
*
* The edge runtime is a generic term for any serverless runtime that supports
* only standard Web APIs such as `fetch`, `Request`, and `Response`, such as
* Cloudflare Workers, Vercel Edge Functions, and AWS Lambda@Edge.
*
* @example
* ```ts
* import { serve } from "inngest/edge";
* import functions from "~/inngest";
*
* export const handler = serve({ id: "my-edge-app", functions });
* ```
*
* @public
*/
const serve = (options) => {
	return commHandler(options).createHandler();
};
/**
* Creates a durable endpoint proxy handler for edge environments.
*
* This handler extracts `runId` and `token` from query parameters,
* fetches the run output from Inngest, decrypts it via middleware
* (if configured), and returns it with CORS headers.
*/
const createDurableEndpointProxyHandler = (options) => {
	return async (req) => {
		const url = new URL(req.url);
		const result = await require_InngestDurableEndpointProxy.handleDurableEndpointProxyRequest(options.client, {
			runId: url.searchParams.get("runId"),
			token: url.searchParams.get("token"),
			method: req.method
		});
		return new Response(result.body, {
			status: result.status,
			headers: result.headers
		});
	};
};
/**
* In an edge runtime, create a function that can wrap any endpoint to be able
* to use steps seamlessly within that API.
*
* The edge runtime is a generic term for any serverless runtime that supports
* only standard Web APIs such as `fetch`, `Request`, and `Response`, such as
* Cloudflare Workers, Vercel Edge Functions, and AWS Lambda@Edge.
*
* @example
* ```ts
* import { Inngest, step } from "inngest";
* import { endpointAdapter } from "inngest/edge";
*
* const inngest = new Inngest({
*   id: "my-app",
*   endpointAdapter,
* });
*
* Bun.serve({
*   routes: {
*     "/": inngest.endpoint(async (req) => {
*       const foo = await step.run("my-step", () => ({ foo: "bar" }));
*
*       return new Response(`Result: ${JSON.stringify(foo)}`);
*     }),
*   },
* });
* ```
*
* You can also configure a custom redirect URL and create a proxy endpoint:
*
* @example
* ```ts
* import { Inngest } from "inngest";
* import { endpointAdapter } from "inngest/edge";
*
* const inngest = new Inngest({
*   id: "my-app",
*   endpointAdapter: endpointAdapter.withOptions({
*     asyncRedirectUrl: "/api/inngest/poll",
*   }),
* });
*
* // Your durable endpoint
* export const GET = inngest.endpoint(async (req) => {
*   const result = await step.run("work", () => "done");
*   return new Response(result);
* });
*
* // Proxy endpoint at /api/inngest/poll - handles CORS and decryption
* export const GET = inngest.endpointProxy();
* ```
*/
const endpointAdapter = require_InngestEndpointAdapter.InngestEndpointAdapter.create((options) => {
	return commHandler(options, options).createSyncHandler();
}, createDurableEndpointProxyHandler);

//#endregion
exports.endpointAdapter = endpointAdapter;
exports.frameworkName = frameworkName;
exports.serve = serve;
//# sourceMappingURL=edge.cjs.map