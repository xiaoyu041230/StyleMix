const require_rolldown_runtime = require('../../_virtual/rolldown_runtime.cjs');
const require_als = require('./als.cjs');
const require_version = require('../../version.cjs');
const require_consts = require('../../helpers/consts.cjs');
const require_types = require('../../types.cjs');
const require_InngestExecution = require('./InngestExecution.cjs');
const require_NonRetriableError = require('../NonRetriableError.cjs');
const require_errors = require('../../helpers/errors.cjs');
const require_functions = require('../../helpers/functions.cjs');
const require_InngestMiddleware = require('../InngestMiddleware.cjs');
const require_access = require('./otel/access.cjs');
const require_promises = require('../../helpers/promises.cjs');
const require_temporal = require('../../helpers/temporal.cjs');
const require_RetryAfterError = require('../RetryAfterError.cjs');
const require_StepError = require('../StepError.cjs');
const require_InngestStepTools = require('../InngestStepTools.cjs');
let zod_v3 = require("zod/v3");
let __opentelemetry_api = require("@opentelemetry/api");
let hash_js = require("hash.js");
hash_js = require_rolldown_runtime.__toESM(hash_js);
let ms = require("ms");
ms = require_rolldown_runtime.__toESM(ms);

//#region src/components/execution/v2.ts
var v2_exports = /* @__PURE__ */ require_rolldown_runtime.__export({
	_internals: () => _internals,
	createV2InngestExecution: () => createV2InngestExecution
});
const { sha1 } = hash_js.default;
/**
* Retry configuration for checkpoint operations.
*
* Checkpoint calls use exponential backoff with jitter to handle transient
* network failures (e.g., dev server temporarily down, cloud hiccup). If
* retries exhaust, the error propagates up - for Sync mode this results in a
* 500 error, for AsyncCheckpointing the caller handles fallback.
*/
const CHECKPOINT_RETRY_OPTIONS = {
	maxAttempts: 5,
	baseDelay: 100
};
const createV2InngestExecution = (options) => {
	return new V2InngestExecution(options);
};
var V2InngestExecution = class extends require_InngestExecution.InngestExecution {
	version = require_consts.ExecutionVersion.V2;
	state;
	fnArg;
	checkpointHandlers;
	timeoutDuration = 1e3 * 10;
	execution;
	userFnToRun;
	/**
	* If we're supposed to run a particular step via `requestedRunStep`, this
	* will be a `Promise` that resolves after no steps have been found for
	* `timeoutDuration` milliseconds.
	*
	* If we're not supposed to run a particular step, this will be `undefined`.
	*/
	timeout;
	/**
	* If we're checkpointing and have been given a maximum runtime, this will be
	* a `Promise` that resolves after that duration has elapsed, allowing us to
	* ensure that we end the execution in good time, especially in serverless
	* environments.
	*/
	checkpointingMaxRuntimeTimer;
	/**
	* If we're checkpointing and have been given a maximum buffer interval, this
	* will be a `Promise` that resolves after that duration has elapsed, allowing
	* us to periodically checkpoint even if the step buffer hasn't filled.
	*/
	checkpointingMaxBufferIntervalTimer;
	constructor(rawOptions) {
		const options = {
			...rawOptions,
			stepMode: rawOptions.stepMode ?? require_types.StepMode.Async
		};
		super(options);
		/**
		* Check we have everything we need for checkpointing
		*/
		if (this.options.stepMode === require_types.StepMode.Sync) {
			if (!this.options.createResponse) throw new Error("createResponse is required for sync step mode");
		}
		this.userFnToRun = this.getUserFnToRun();
		this.state = this.createExecutionState();
		this.fnArg = this.createFnArg();
		this.checkpointHandlers = this.createCheckpointHandlers();
		this.initializeTimer(this.state);
		this.initializeCheckpointRuntimeTimer(this.state);
		this.debug("created new V2 execution for run;", this.options.requestedRunStep ? `wanting to run step "${this.options.requestedRunStep}"` : "discovering steps");
		this.debug("existing state keys:", Object.keys(this.state.stepState));
	}
	/**
	* Idempotently start the execution of the user's function.
	*/
	start() {
		if (!this.execution) {
			this.debug("starting V2 execution");
			const tracer = __opentelemetry_api.trace.getTracer("inngest", require_version.version);
			this.execution = require_als.getAsyncLocalStorage().then((als) => {
				return als.run({
					app: this.options.client,
					execution: {
						ctx: this.fnArg,
						instance: this
					}
				}, async () => {
					return tracer.startActiveSpan("inngest.execution", (span) => {
						require_access.clientProcessorMap.get(this.options.client)?.declareStartingSpan({
							span,
							runId: this.options.runId,
							traceparent: this.options.headers[require_consts.headerKeys.TraceParent],
							tracestate: this.options.headers[require_consts.headerKeys.TraceState]
						});
						return this._start().then((result) => {
							this.debug("result:", result);
							return result;
						}).finally(() => {
							span.end();
						});
					});
				});
			});
		}
		return this.execution;
	}
	addMetadata(stepId, kind, scope, op, values) {
		if (!this.state.metadata) this.state.metadata = /* @__PURE__ */ new Map();
		const updates = this.state.metadata.get(stepId) ?? [];
		updates.push({
			kind,
			scope,
			op,
			values
		});
		this.state.metadata.set(stepId, updates);
		return true;
	}
	/**
	* Starts execution of the user's function and the core loop.
	*/
	async _start() {
		try {
			const allCheckpointHandler = this.getCheckpointHandler("");
			this.state.hooks = await this.initializeMiddleware();
			await this.startExecution();
			let i = 0;
			for await (const checkpoint of this.state.loop) {
				await allCheckpointHandler(checkpoint, i);
				const result = await this.getCheckpointHandler(checkpoint.type)(checkpoint, i++);
				if (result) return result;
			}
		} catch (error) {
			return await this.transformOutput({ error });
		} finally {
			this.state.loop.return();
			await this.state.hooks?.beforeResponse?.();
		}
		/**
		* If we're here, the generator somehow finished without returning a value.
		* This should never happen.
		*/
		throw new Error("Core loop finished without returning a value");
	}
	async checkpoint(steps) {
		if (this.options.stepMode === require_types.StepMode.Sync) if (!this.state.checkpointedRun) {
			const res = await require_promises.retryWithBackoff(() => this.options.client["inngestApi"].checkpointNewRun({
				runId: this.fnArg.runId,
				event: this.fnArg.event,
				steps,
				executionVersion: this.version,
				retries: this.fnArg.maxAttempts ?? require_consts.defaultMaxRetries
			}), CHECKPOINT_RETRY_OPTIONS);
			this.state.checkpointedRun = {
				appId: res.data.app_id,
				fnId: res.data.fn_id,
				token: res.data.token
			};
		} else await require_promises.retryWithBackoff(() => this.options.client["inngestApi"].checkpointSteps({
			appId: this.state.checkpointedRun.appId,
			fnId: this.state.checkpointedRun.fnId,
			runId: this.fnArg.runId,
			steps
		}), CHECKPOINT_RETRY_OPTIONS);
		else if (this.options.stepMode === require_types.StepMode.AsyncCheckpointing) {
			if (!this.options.queueItemId) throw new Error("Missing queueItemId for async checkpointing. This is a bug in the Inngest SDK.");
			if (!this.options.internalFnId) throw new Error("Missing internalFnId for async checkpointing. This is a bug in the Inngest SDK.");
			await require_promises.retryWithBackoff(() => this.options.client["inngestApi"].checkpointStepsAsync({
				runId: this.fnArg.runId,
				fnId: this.options.internalFnId,
				queueItemId: this.options.queueItemId,
				steps
			}), CHECKPOINT_RETRY_OPTIONS);
		} else throw new Error("Checkpointing is only supported in Sync and AsyncCheckpointing step modes. This is a bug in the Inngest SDK.");
	}
	async checkpointAndSwitchToAsync(steps) {
		await this.checkpoint(steps);
		if (!this.state.checkpointedRun?.token) throw new Error("Failed to checkpoint and switch to async mode");
		return {
			type: "change-mode",
			ctx: this.fnArg,
			ops: this.ops,
			to: require_types.StepMode.Async,
			token: this.state.checkpointedRun?.token
		};
	}
	/**
	* Returns whether we're in the final attempt of execution, or `null` if we
	* can't determine this in the SDK.
	*/
	inFinalAttempt() {
		if (typeof this.fnArg.maxAttempts !== "number") return null;
		return this.fnArg.attempt + 1 >= this.fnArg.maxAttempts;
	}
	/**
	* Creates a handler for every checkpoint type, defining what to do when we
	* reach that checkpoint in the core loop.
	*/
	createCheckpointHandlers() {
		const commonCheckpointHandler = (checkpoint) => {
			this.debug(`${this.options.stepMode} checkpoint:`, checkpoint);
		};
		const stepRanHandler = async (stepResult) => {
			const transformResult = await this.transformOutput(stepResult);
			/**
			* Transforming output will always return either function rejection or
			* resolution. In most cases, this can be immediately returned, but in
			* this particular case we want to handle it differently.
			*/
			if (transformResult.type === "function-resolved") return {
				type: "step-ran",
				ctx: transformResult.ctx,
				ops: transformResult.ops,
				step: {
					...stepResult,
					data: transformResult.data
				}
			};
			else if (transformResult.type === "function-rejected") {
				const stepForResponse = {
					...stepResult,
					error: transformResult.error
				};
				if (stepResult.op === require_types.StepOpCode.StepFailed) {
					const ser = require_errors.serializeError(transformResult.error);
					stepForResponse.data = {
						__serialized: true,
						name: ser.name,
						message: ser.message,
						stack: ""
					};
				}
				return {
					type: "step-ran",
					ctx: transformResult.ctx,
					ops: transformResult.ops,
					retriable: transformResult.retriable,
					step: stepForResponse
				};
			}
			return transformResult;
		};
		const maybeReturnNewSteps = async (steps) => {
			const newSteps = await this.filterNewSteps(Array.from(steps.values()));
			if (newSteps) return {
				type: "steps-found",
				ctx: this.fnArg,
				ops: this.ops,
				steps: newSteps
			};
		};
		const attemptCheckpointAndResume = async (stepResult, resume = true, force = false) => {
			if (stepResult) {
				const stepToResume = this.resumeStepWithResult(stepResult, resume);
				const transformedData = (await this.state.hooks?.transformOutput?.({
					result: { data: stepResult.data },
					step: stepResult
				}))?.result?.data ?? stepResult.data;
				this.state.checkpointingStepBuffer.push({
					...stepToResume,
					data: transformedData
				});
			}
			if (force || !this.options.checkpointingConfig?.bufferedSteps || this.state.checkpointingStepBuffer.length >= this.options.checkpointingConfig.bufferedSteps) {
				this.debug("checkpointing and resuming execution after step run");
				try {
					this.debug(`checkpointing all buffered steps:`, this.state.checkpointingStepBuffer.map((op) => op.displayName || op.id).join(", "));
					await this.checkpoint(this.state.checkpointingStepBuffer);
					return;
				} catch (err) {
					this.debug("error checkpointing after step run, so falling back to async", err);
					if (stepResult) return stepRanHandler(stepResult);
				} finally {
					this.state.checkpointingStepBuffer = [];
				}
			} else this.debug(`not checkpointing yet, continuing execution as we haven't reached buffered step limit of ${this.options.checkpointingConfig?.bufferedSteps}`);
		};
		const syncHandlers = {
			"": commonCheckpointHandler,
			"function-resolved": async (checkpoint, i) => {
				const transformedData = (await this.state.hooks?.transformOutput?.({
					result: { data: checkpoint.data },
					step: this.state.executingStep
				}))?.result?.data ?? checkpoint.data;
				await this.checkpoint([{
					op: require_types.StepOpCode.RunComplete,
					id: _internals.hashId("complete"),
					data: await this.options.createResponse(transformedData)
				}]);
				return await this.transformOutput({ data: checkpoint.data });
			},
			"function-rejected": async (checkpoint) => {
				if (this.inFinalAttempt()) return await this.transformOutput({ error: checkpoint.error });
				return this.checkpointAndSwitchToAsync([{
					id: _internals.hashId("complete"),
					op: require_types.StepOpCode.StepError,
					error: checkpoint.error
				}]);
			},
			"step-not-found": () => {
				return {
					type: "function-rejected",
					ctx: this.fnArg,
					error: /* @__PURE__ */ new Error("Step not found when checkpointing; this should never happen"),
					ops: this.ops,
					retriable: false
				};
			},
			"steps-found": async ({ steps }) => {
				if (steps.length !== 1 || steps[0].mode !== require_types.StepMode.Sync) return this.checkpointAndSwitchToAsync(steps.map((step) => ({
					...step,
					id: step.hashedId
				})));
				const result = await this.executeStep(steps[0]);
				const transformed = await stepRanHandler(result);
				if (transformed.type !== "step-ran") throw new Error("Unexpected checkpoint handler result type after running step in sync mode");
				if (result.error) return this.checkpointAndSwitchToAsync([transformed.step]);
				const stepForCheckpoint = {
					...this.resumeStepWithResult(result),
					data: transformed.step.data
				};
				await this.checkpoint([stepForCheckpoint]);
			},
			"checkpointing-runtime-reached": () => {
				return this.checkpointAndSwitchToAsync([{
					op: require_types.StepOpCode.DiscoveryRequest,
					id: _internals.hashId("discovery-request")
				}]);
			},
			"checkpointing-buffer-interval-reached": () => {
				return attemptCheckpointAndResume(void 0, false, true);
			}
		};
		const asyncHandlers = {
			"": commonCheckpointHandler,
			"function-resolved": async ({ data }) => {
				if (this.options.createResponse) data = await this.options.createResponse(data);
				return await this.transformOutput({ data });
			},
			"function-rejected": async (checkpoint) => {
				return await this.transformOutput({ error: checkpoint.error });
			},
			"steps-found": async ({ steps }) => {
				const stepResult = await this.tryExecuteStep(steps);
				if (stepResult) return stepRanHandler(stepResult);
				return maybeReturnNewSteps(steps);
			},
			"step-not-found": ({ step }) => {
				return {
					type: "step-not-found",
					ctx: this.fnArg,
					ops: this.ops,
					step
				};
			},
			"checkpointing-runtime-reached": () => {
				throw new Error("Checkpointing maximum runtime reached, but this is not in a checkpointing step mode. This is a bug in the Inngest SDK.");
			},
			"checkpointing-buffer-interval-reached": () => {
				throw new Error("Checkpointing maximum buffer interval reached, but this is not in a checkpointing step mode. This is a bug in the Inngest SDK.");
			}
		};
		const asyncCheckpointingHandlers = {
			"": commonCheckpointHandler,
			"function-resolved": async (checkpoint, i) => {
				const output = await asyncHandlers["function-resolved"](checkpoint, i);
				if (output?.type === "function-resolved") {
					const steps = this.state.checkpointingStepBuffer.concat({
						op: require_types.StepOpCode.RunComplete,
						id: _internals.hashId("complete"),
						data: output.data
					});
					return {
						type: "steps-found",
						ctx: output.ctx,
						ops: output.ops,
						steps
					};
				}
			},
			"function-rejected": async (checkpoint) => {
				if (this.state.checkpointingStepBuffer.length) await attemptCheckpointAndResume(void 0, false);
				return await this.transformOutput({ error: checkpoint.error });
			},
			"step-not-found": asyncHandlers["step-not-found"],
			"steps-found": async ({ steps }) => {
				const { stepsToResume, newSteps } = steps.reduce((acc, step) => {
					if (!step.hasStepState) acc.newSteps.push(step);
					else if (!step.fulfilled) acc.stepsToResume.push(step);
					return acc;
				}, {
					stepsToResume: [],
					newSteps: []
				});
				this.debug("split found steps in to:", {
					stepsToResume: stepsToResume.length,
					newSteps: newSteps.length
				});
				if (!this.options.requestedRunStep && newSteps.length) {
					const stepResult = await this.tryExecuteStep(newSteps);
					if (stepResult) {
						this.debug(`executed step "${stepResult.id}" successfully`);
						if (stepResult.error) return stepRanHandler(stepResult);
						return await attemptCheckpointAndResume(stepResult);
					}
					return maybeReturnNewSteps(steps);
				}
				if (stepsToResume.length) {
					this.debug(`resuming ${stepsToResume.length} steps`);
					for (const st of stepsToResume) this.resumeStepWithResult({
						...st,
						id: st.hashedId
					});
				}
			},
			"checkpointing-runtime-reached": async () => {
				return {
					type: "steps-found",
					ctx: this.fnArg,
					ops: this.ops,
					steps: [{
						op: require_types.StepOpCode.DiscoveryRequest,
						id: _internals.hashId("discovery-request")
					}]
				};
			},
			"checkpointing-buffer-interval-reached": () => {
				return attemptCheckpointAndResume(void 0, false, true);
			}
		};
		return {
			[require_types.StepMode.Async]: asyncHandlers,
			[require_types.StepMode.Sync]: syncHandlers,
			[require_types.StepMode.AsyncCheckpointing]: asyncCheckpointingHandlers
		};
	}
	getCheckpointHandler(type) {
		return this.checkpointHandlers[this.options.stepMode][type];
	}
	async tryExecuteStep(steps) {
		const hashedStepIdToRun = this.options.requestedRunStep || this.getEarlyExecRunStep(steps);
		if (!hashedStepIdToRun) return;
		const step = steps.find((step$1) => step$1.hashedId === hashedStepIdToRun && step$1.fn);
		if (step) return await this.executeStep(step);
		this.timeout?.reset();
	}
	/**
	* Given a list of outgoing ops, decide if we can execute an op early and
	* return the ID of the step to execute if we can.
	*/
	getEarlyExecRunStep(steps) {
		/**
		* We may have been disabled due to parallelism, in which case we can't
		* immediately execute unless explicitly requested.
		*/
		if (this.options.disableImmediateExecution) return;
		const unfulfilledSteps = steps.filter((step) => !step.fulfilled);
		if (unfulfilledSteps.length !== 1) return;
		const op = unfulfilledSteps[0];
		if (op && op.op === require_types.StepOpCode.StepPlanned) return op.hashedId;
	}
	async filterNewSteps(foundSteps) {
		if (this.options.requestedRunStep) return;
		/**
		* Gather any steps that aren't memoized and report them.
		*/
		const newSteps = foundSteps.reduce((acc, step) => {
			if (!step.hasStepState) acc.push(step);
			return acc;
		}, []);
		if (!newSteps.length) return;
		/**
		* We're finishing up; let's trigger the last of the hooks.
		*/
		await this.state.hooks?.afterMemoization?.();
		await this.state.hooks?.beforeExecution?.();
		await this.state.hooks?.afterExecution?.();
		const stepList = newSteps.map((step) => ({
			displayName: step.displayName,
			op: step.op,
			id: step.hashedId,
			name: step.name,
			opts: step.opts,
			userland: step.userland
		}));
		/**
		* We also run `onSendEvent` middleware hooks against `step.invoke()` steps
		* to ensure that their `data` is transformed correctly.
		*/
		return await this.transformNewSteps(stepList);
	}
	/**
	* Using middleware, transform any newly-found steps before returning them to
	* an Inngest Server.
	*/
	async transformNewSteps(steps) {
		return Promise.all(steps.map(async (step) => {
			if (step.op !== require_types.StepOpCode.InvokeFunction) return step;
			/**
			* For each event being sent, create a new `onSendEvent` hook stack to
			* process it. We do this as middleware hooks are intended to run once
			* during each lifecycle (onFunctionRun or onSendEvent) and here, a hook
			* is run for every single event.
			*
			* This is done because a developer can use this hook to filter out
			* events entirely; if we batch all of the events together, we can't
			* tell which ones were filtered out if we're processing >1 invocation
			* here.
			*/
			const transformedPayload = await (await require_InngestMiddleware.getHookStack(this.options.fn["middleware"], "onSendEvent", void 0, {
				transformInput: (prev, output) => {
					return {
						...prev,
						...output
					};
				},
				transformOutput: (prev, output) => {
					return { result: {
						...prev.result,
						...output?.result
					} };
				}
			})).transformInput?.({ payloads: [{
				...step.opts?.payload ?? {},
				name: require_consts.internalEvents.FunctionInvoked
			}] });
			const newPayload = require_InngestStepTools.invokePayloadSchema.parse(transformedPayload?.payloads?.[0] ?? {});
			return {
				...step,
				opts: {
					...step.opts,
					payload: {
						...step.opts?.payload ?? {},
						...newPayload
					}
				}
			};
		}));
	}
	async executeStep({ id, name, opts, fn, displayName, userland, hashedId }) {
		this.debug(`preparing to execute step "${id}"`);
		this.timeout?.clear();
		await this.state.hooks?.afterMemoization?.();
		await this.state.hooks?.beforeExecution?.();
		const outgoingOp = {
			id: hashedId,
			op: require_types.StepOpCode.StepRun,
			name,
			opts,
			displayName,
			userland
		};
		this.state.executingStep = outgoingOp;
		const store = await require_als.getAsyncCtx();
		if (store?.execution) store.execution.executingStep = {
			id,
			name: displayName
		};
		this.debug(`executing step "${id}"`);
		let interval;
		return require_promises.goIntervalTiming(() => require_promises.runAsPromise(fn)).finally(async () => {
			this.debug(`finished executing step "${id}"`);
			delete this.state.executingStep;
			if (store?.execution) delete store.execution.executingStep;
			await this.state.hooks?.afterExecution?.();
		}).then(async ({ resultPromise, interval: _interval }) => {
			interval = _interval;
			const metadata = this.state.metadata?.get(id);
			return {
				...outgoingOp,
				data: await resultPromise,
				...metadata && metadata.length > 0 ? { metadata } : {}
			};
		}).catch((error) => {
			let errorIsRetriable = true;
			if (error instanceof require_NonRetriableError.NonRetriableError || error?.name === "NonRetriableError") errorIsRetriable = false;
			else if (this.fnArg.maxAttempts && this.fnArg?.maxAttempts - 1 === this.fnArg.attempt) errorIsRetriable = false;
			const metadata = this.state.metadata?.get(id);
			const serialized = require_errors.serializeError(error);
			if (errorIsRetriable) return {
				...outgoingOp,
				op: require_types.StepOpCode.StepError,
				error: serialized,
				...metadata && metadata.length > 0 ? { metadata } : {}
			};
			else return {
				...outgoingOp,
				op: require_types.StepOpCode.StepFailed,
				error: serialized,
				...metadata && metadata.length > 0 ? { metadata } : {}
			};
		}).then((op) => ({
			...op,
			timing: interval
		}));
	}
	/**
	* Starts execution of the user's function, including triggering checkpoints
	* and middleware hooks where appropriate.
	*/
	async startExecution() {
		/**
		* Mutate input as neccessary based on middleware.
		*/
		await this.transformInput();
		/**
		* Start the timer to time out the run if needed.
		*/
		this.timeout?.start();
		this.checkpointingMaxRuntimeTimer?.start();
		this.checkpointingMaxBufferIntervalTimer?.start();
		await this.state.hooks?.beforeMemoization?.();
		/**
		* If we had no state to begin with, immediately end the memoization phase.
		*/
		if (this.state.allStateUsed()) {
			await this.state.hooks?.afterMemoization?.();
			await this.state.hooks?.beforeExecution?.();
		}
		/**
		* Trigger the user's function.
		*/
		require_promises.runAsPromise(() => this.userFnToRun(this.fnArg)).finally(async () => {
			await this.state.hooks?.afterMemoization?.();
			await this.state.hooks?.beforeExecution?.();
			await this.state.hooks?.afterExecution?.();
		}).then((data) => {
			this.state.setCheckpoint({
				type: "function-resolved",
				data
			});
		}).catch((error) => {
			this.state.setCheckpoint({
				type: "function-rejected",
				error
			});
		});
	}
	/**
	* Using middleware, transform input before running.
	*/
	async transformInput() {
		const inputMutations = await this.state.hooks?.transformInput?.({
			ctx: { ...this.fnArg },
			steps: Object.values(this.state.stepState),
			fn: this.options.fn,
			reqArgs: this.options.reqArgs
		});
		if (inputMutations?.ctx) this.fnArg = inputMutations.ctx;
		if (inputMutations?.steps) this.state.stepState = Object.fromEntries(inputMutations.steps.map((step) => [step.id, step]));
	}
	/**
	* Using middleware, transform output before returning.
	*/
	async transformOutput(dataOrError) {
		const output = { ...dataOrError };
		const isStepExecution = Boolean(this.state.executingStep);
		const transformedOutput = await this.state.hooks?.transformOutput?.({
			result: { ...output },
			step: this.state.executingStep
		});
		const { data, error } = {
			...output,
			...transformedOutput?.result
		};
		if (!isStepExecution) await this.state.hooks?.finished?.({ result: { ...typeof error !== "undefined" ? { error } : { data } } });
		if (typeof error !== "undefined") {
			/**
			* Ensure we give middleware the chance to decide on retriable behaviour
			* by looking at the error returned from output transformation.
			*/
			let retriable = !(error instanceof require_NonRetriableError.NonRetriableError || error?.name === "NonRetriableError" || error instanceof require_StepError.StepError && error === this.state.recentlyRejectedStepError);
			if (retriable && (error instanceof require_RetryAfterError.RetryAfterError || error?.name === "RetryAfterError")) retriable = error.retryAfter;
			const serializedError = require_errors.minifyPrettyError(require_errors.serializeError(error));
			return {
				type: "function-rejected",
				ctx: this.fnArg,
				ops: this.ops,
				error: serializedError,
				retriable
			};
		}
		return {
			type: "function-resolved",
			ctx: this.fnArg,
			ops: this.ops,
			data: require_functions.undefinedToNull(data)
		};
	}
	createExecutionState() {
		const d = require_promises.createDeferredPromiseWithStack();
		let checkpointResolve = d.deferred.resolve;
		const checkpointResults = d.results;
		const loop = (async function* (cleanUp) {
			try {
				while (true) {
					const res = (await checkpointResults.next()).value;
					if (res) yield res;
				}
			} finally {
				cleanUp?.();
			}
		})(() => {
			this.timeout?.clear();
			this.checkpointingMaxRuntimeTimer?.clear();
			this.checkpointingMaxBufferIntervalTimer?.clear();
			checkpointResults.return();
		});
		const stepsToFulfill = Object.keys(this.options.stepState).length;
		return {
			stepState: this.options.stepState,
			stepsToFulfill,
			steps: /* @__PURE__ */ new Map(),
			loop,
			hasSteps: Boolean(stepsToFulfill),
			stepCompletionOrder: [...this.options.stepCompletionOrder],
			remainingStepsToBeSeen: new Set(this.options.stepCompletionOrder),
			setCheckpoint: (checkpoint) => {
				this.debug("setting checkpoint:", checkpoint.type);
				({resolve: checkpointResolve} = checkpointResolve(checkpoint));
			},
			allStateUsed: () => {
				return this.state.remainingStepsToBeSeen.size === 0;
			},
			checkpointingStepBuffer: [],
			metadata: /* @__PURE__ */ new Map()
		};
	}
	get ops() {
		return Object.fromEntries(this.state.steps);
	}
	createFnArg() {
		const step = this.createStepTools();
		let fnArg = {
			...this.options.data,
			step
		};
		/**
		* Handle use of the `onFailure` option by deserializing the error.
		*/
		if (this.options.isFailureHandler) {
			const eventData = zod_v3.z.object({ error: require_types.jsonErrorSchema }).parse(fnArg.event?.data);
			fnArg = {
				...fnArg,
				error: require_errors.deserializeError(eventData.error)
			};
		}
		return this.options.transformCtx?.(fnArg) ?? fnArg;
	}
	createStepTools() {
		/**
		* A list of steps that have been found and are being rolled up before being
		* reported to the core loop.
		*/
		const foundStepsToReport = /* @__PURE__ */ new Map();
		/**
		* A map of the subset of found steps to report that have not yet been
		* handled. Used for fast access to steps that need to be handled in order.
		*/
		const unhandledFoundStepsToReport = /* @__PURE__ */ new Map();
		/**
		* A map of the latest sequential step indexes found for each step ID. Used
		* to ensure that we don't index steps in parallel.
		*
		* Note that these must be sequential; if we've seen or assigned `a:1`,
		* `a:2` and `a:4`, the latest sequential step index is `2`.
		*
		*/
		const expectedNextStepIndexes = /* @__PURE__ */ new Map();
		/**
		* A promise that's used to ensure that step reporting cannot be run more than
		* once in a given asynchronous time span.
		*/
		let foundStepsReportPromise;
		/**
		* A promise that's used to represent middleware hooks running before
		* execution.
		*/
		let beforeExecHooksPromise;
		/**
		* A helper used to report steps to the core loop. Used after adding an item
		* to `foundStepsToReport`.
		*/
		const reportNextTick = () => {
			if (foundStepsReportPromise) return;
			foundStepsReportPromise = require_promises.resolveAfterPending().then(() => beforeExecHooksPromise).then(() => {
				foundStepsReportPromise = void 0;
				for (const [hashedId, step] of unhandledFoundStepsToReport) if ((this.options.stepMode === require_types.StepMode.Async || step.hasStepState) && step.handle()) {
					unhandledFoundStepsToReport.delete(hashedId);
					if (step.fulfilled) foundStepsToReport.delete(step.id);
				}
				if (foundStepsToReport.size) {
					const steps = [...foundStepsToReport.values()];
					foundStepsToReport.clear();
					unhandledFoundStepsToReport.clear();
					this.state.setCheckpoint({
						type: "steps-found",
						steps
					});
					return;
				}
			});
		};
		/**
		* A helper used to push a step to the list of steps to report.
		*/
		const pushStepToReport = (step) => {
			foundStepsToReport.set(step.hashedId, step);
			unhandledFoundStepsToReport.set(step.hashedId, step);
			reportNextTick();
		};
		const stepHandler = async ({ args, matchOp, opts }) => {
			await beforeExecHooksPromise;
			const opId = matchOp(require_InngestStepTools.getStepOptions(args[0]), ...args.slice(1));
			if (this.state.executingStep)
 /**
			* If a step is found after asynchronous actions during another step's
			* execution, everything is fine. The problem here is if we've found
			* that a step nested inside another a step, which is something we don't
			* support at the time of writing.
			*
			* In this case, we could use something like Async Hooks to understand
			* how the step is being triggered, though this isn't available in all
			* environments.
			*
			* Therefore, we'll only show a warning here to indicate that this is
			* potentially an issue.
			*/
			this.options.client["warnMetadata"]({ run_id: this.fnArg.runId }, require_errors.ErrCode.NESTING_STEPS, require_errors.prettyError({
				whatHappened: `We detected that you have nested \`step.*\` tooling in \`${opId.displayName ?? opId.id}\``,
				consequences: "Nesting `step.*` tooling is not supported.",
				type: "warn",
				reassurance: "It's possible to see this warning if steps are separated by regular asynchronous calls, which is fine.",
				stack: true,
				toFixNow: "Make sure you're not using `step.*` tooling inside of other `step.*` tooling. If you need to compose steps together, you can create a new async function and call it from within your step function, or use promise chaining.",
				code: require_errors.ErrCode.NESTING_STEPS
			}));
			if (this.state.steps.has(_internals.hashId(opId.id))) {
				const originalId = opId.id;
				const expectedNextIndex = expectedNextStepIndexes.get(originalId) ?? 1;
				for (let i = expectedNextIndex;; i++) {
					const newId = originalId + require_InngestStepTools.STEP_INDEXING_SUFFIX + i;
					if (!this.state.steps.has(_internals.hashId(newId))) {
						expectedNextStepIndexes.set(originalId, i + 1);
						opId.id = newId;
						opId.userland.index = i;
						break;
					}
				}
			}
			const { promise, resolve, reject } = require_promises.createDeferredPromise();
			const hashedId = _internals.hashId(opId.id);
			const stepState = this.state.stepState[hashedId];
			let isFulfilled = false;
			if (stepState) {
				stepState.seen = true;
				this.state.remainingStepsToBeSeen.delete(hashedId);
				if (typeof stepState.input === "undefined") isFulfilled = true;
			}
			let extraOpts;
			let fnArgs = [...args];
			if (typeof stepState?.input !== "undefined" && Array.isArray(stepState.input)) switch (opId.op) {
				case require_types.StepOpCode.StepPlanned:
					fnArgs = [...args.slice(0, 2), ...stepState.input];
					extraOpts = { input: [...stepState.input] };
					break;
				case require_types.StepOpCode.AiGateway:
					extraOpts = { body: {
						...typeof opId.opts?.body === "object" ? { ...opId.opts.body } : {},
						...stepState.input[0]
					} };
					break;
			}
			const step = {
				...opId,
				opts: {
					...opId.opts,
					...extraOpts
				},
				rawArgs: fnArgs,
				hashedId,
				input: stepState?.input,
				fn: opts?.fn ? () => opts.fn?.(this.fnArg, ...fnArgs) : void 0,
				promise,
				fulfilled: isFulfilled,
				hasStepState: Boolean(stepState),
				displayName: opId.displayName ?? opId.id,
				handled: false,
				handle: () => {
					if (step.handled) return false;
					this.debug(`handling step "${hashedId}"`);
					step.handled = true;
					const result = this.state.stepState[hashedId];
					if (step.fulfilled && result) {
						result.fulfilled = true;
						Promise.all([
							result.data,
							result.error,
							result.input
						]).then(() => {
							if (typeof result.data !== "undefined") resolve(result.data);
							else {
								this.state.recentlyRejectedStepError = new require_StepError.StepError(opId.id, result.error);
								reject(this.state.recentlyRejectedStepError);
							}
						});
					}
					return true;
				}
			};
			this.state.steps.set(hashedId, step);
			this.state.hasSteps = true;
			pushStepToReport(step);
			/**
			* If this is the last piece of state we had, we've now finished
			* memoizing.
			*/
			if (!beforeExecHooksPromise && this.state.allStateUsed()) await (beforeExecHooksPromise = (async () => {
				await this.state.hooks?.afterMemoization?.();
				await this.state.hooks?.beforeExecution?.();
			})());
			return promise;
		};
		return require_InngestStepTools.createStepTools(this.options.client, this, stepHandler);
	}
	resumeStepWithResult(resultOp, resume = true) {
		const userlandStep = this.state.steps.get(resultOp.id);
		if (!userlandStep) throw new Error("Step not found in memoization state during async checkpointing; this should never happen and is a bug in the Inngest SDK");
		userlandStep.data = require_functions.undefinedToNull(resultOp.data);
		userlandStep.timing = resultOp.timing;
		userlandStep.op = resultOp.op;
		userlandStep.id = resultOp.id;
		userlandStep.hasStepState = true;
		if (resume) {
			userlandStep.fulfilled = true;
			this.state.stepState[resultOp.id] = userlandStep;
			userlandStep.handle();
		}
		return userlandStep;
	}
	getUserFnToRun() {
		if (!this.options.isFailureHandler) return this.options.fn["fn"];
		if (!this.options.fn["onFailureFn"])
 /**
		* Somehow, we've ended up detecting that this is a failure handler but
		* doesn't have an `onFailure` function. This should never happen.
		*/
		throw new Error("Cannot find function `onFailure` handler");
		return this.options.fn["onFailureFn"];
	}
	initializeTimer(state) {
		if (!this.options.requestedRunStep) return;
		this.timeout = require_promises.createTimeoutPromise(this.timeoutDuration);
		this.timeout.then(async () => {
			await this.state.hooks?.afterMemoization?.();
			await this.state.hooks?.beforeExecution?.();
			await this.state.hooks?.afterExecution?.();
			state.setCheckpoint({
				type: "step-not-found",
				step: {
					id: this.options.requestedRunStep,
					op: require_types.StepOpCode.StepNotFound
				}
			});
		});
	}
	initializeCheckpointRuntimeTimer(state) {
		this.debug("initializing checkpointing runtime timers", this.options.checkpointingConfig);
		if (this.options.checkpointingConfig?.maxRuntime) {
			const maxRuntimeMs = require_temporal.isTemporalDuration(this.options.checkpointingConfig.maxRuntime) ? this.options.checkpointingConfig.maxRuntime.total({ unit: "milliseconds" }) : typeof this.options.checkpointingConfig.maxRuntime === "string" ? (0, ms.default)(this.options.checkpointingConfig.maxRuntime) : this.options.checkpointingConfig.maxRuntime;
			if (Number.isFinite(maxRuntimeMs) && maxRuntimeMs > 0) {
				this.checkpointingMaxRuntimeTimer = require_promises.createTimeoutPromise(maxRuntimeMs);
				this.checkpointingMaxRuntimeTimer.then(async () => {
					await this.state.hooks?.afterMemoization?.();
					await this.state.hooks?.beforeExecution?.();
					await this.state.hooks?.afterExecution?.();
					state.setCheckpoint({ type: "checkpointing-runtime-reached" });
				});
			}
		}
		if (this.options.checkpointingConfig?.maxInterval) {
			const maxIntervalMs = require_temporal.isTemporalDuration(this.options.checkpointingConfig.maxInterval) ? this.options.checkpointingConfig.maxInterval.total({ unit: "milliseconds" }) : typeof this.options.checkpointingConfig.maxInterval === "string" ? (0, ms.default)(this.options.checkpointingConfig.maxInterval) : this.options.checkpointingConfig.maxInterval;
			if (Number.isFinite(maxIntervalMs) && maxIntervalMs > 0) {
				this.checkpointingMaxBufferIntervalTimer = require_promises.createTimeoutPromise(maxIntervalMs);
				this.checkpointingMaxBufferIntervalTimer.then(async () => {
					state.setCheckpoint({ type: "checkpointing-buffer-interval-reached" });
					this.checkpointingMaxBufferIntervalTimer?.reset();
				});
			}
		}
	}
	async initializeMiddleware() {
		const ctx = this.options.data;
		return await require_InngestMiddleware.getHookStack(this.options.fn["middleware"], "onFunctionRun", {
			ctx,
			fn: this.options.fn,
			steps: Object.values(this.options.stepState),
			reqArgs: this.options.reqArgs
		}, {
			transformInput: (prev, output) => {
				return {
					ctx: {
						...prev.ctx,
						...output?.ctx
					},
					fn: this.options.fn,
					steps: prev.steps.map((step, i) => ({
						...step,
						...output?.steps?.[i]
					})),
					reqArgs: prev.reqArgs
				};
			},
			transformOutput: (prev, output) => {
				return {
					result: {
						...prev.result,
						...output?.result
					},
					step: prev.step
				};
			}
		});
	}
};
const hashId = (id) => {
	return sha1().update(id).digest("hex");
};
const hashOp = (op) => {
	return {
		...op,
		id: hashId(op.id)
	};
};
/**
* Exported for testing.
*/
const _internals = {
	hashOp,
	hashId
};

//#endregion
exports.createV2InngestExecution = createV2InngestExecution;
Object.defineProperty(exports, 'v2_exports', {
  enumerable: true,
  get: function () {
    return v2_exports;
  }
});
//# sourceMappingURL=v2.cjs.map