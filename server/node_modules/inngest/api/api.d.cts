import { ExecutionVersion } from "../helpers/consts.cjs";
import { APIStepPayload, MetadataTarget, OutgoingOp, Result } from "../types.cjs";
import { BatchResponse, ErrorResponse, StepsResponse } from "./schema.cjs";
import { Mode } from "../helpers/env.cjs";
import { z } from "zod/v3";
import { fetch } from "cross-fetch";

//#region src/api/api.d.ts
type FetchT = typeof fetch;
declare const checkpointNewRunResponseSchema: z.ZodObject<{
  data: z.ZodObject<{
    fn_id: z.ZodString;
    app_id: z.ZodString;
    run_id: z.ZodString;
    token: z.ZodOptional<z.ZodString>;
  }, "strip", z.ZodTypeAny, {
    run_id: string;
    fn_id: string;
    app_id: string;
    token?: string | undefined;
  }, {
    run_id: string;
    fn_id: string;
    app_id: string;
    token?: string | undefined;
  }>;
}, "strip", z.ZodTypeAny, {
  data: {
    run_id: string;
    fn_id: string;
    app_id: string;
    token?: string | undefined;
  };
}, {
  data: {
    run_id: string;
    fn_id: string;
    app_id: string;
    token?: string | undefined;
  };
}>;
declare namespace InngestApi {
  interface Options {
    baseUrl?: string;
    signingKey: string;
    signingKeyFallback: string | undefined;
    fetch: FetchT;
    mode: Mode;
  }
  interface Subscription {
    topics: string[];
    channel: string;
  }
  interface PublishOptions extends Subscription {
    runId?: string;
  }
  interface SendSignalOptions {
    signal: string;
    data?: unknown;
  }
  interface SendSignalResponse {
    /**
     * The ID of the run that was signaled.
     *
     * If this is undefined, the signal could not be matched to a run.
     */
    runId: string | undefined;
  }
}
declare class InngestApi {
  apiBaseUrl?: string;
  private signingKey;
  private signingKeyFallback;
  private readonly fetch;
  private mode;
  constructor({
    baseUrl,
    signingKey,
    signingKeyFallback,
    fetch,
    mode
  }: InngestApi.Options);
  private get hashedKey();
  private get hashedFallbackKey();
  setSigningKey(key: string | undefined): void;
  setSigningKeyFallback(key: string | undefined): void;
  private getTargetUrl;
  private req;
  getRunSteps(runId: string, version: ExecutionVersion): Promise<Result<StepsResponse, ErrorResponse>>;
  getRunBatch(runId: string): Promise<Result<BatchResponse, ErrorResponse>>;
  publish(publishOptions: InngestApi.PublishOptions, data: any): Promise<Result<void, ErrorResponse>>;
  sendSignal(signalOptions: InngestApi.SendSignalOptions, options?: {
    headers?: Record<string, string>;
  }): Promise<Result<InngestApi.SendSignalResponse, ErrorResponse>>;
  getSubscriptionToken(channel: string, topics: string[]): Promise<string>;
  updateMetadata(args: {
    target: MetadataTarget;
    metadata: Array<{
      kind: string;
      op: string;
      values: Record<string, unknown>;
    }>;
  }, options?: {
    headers?: Record<string, string>;
  }): Promise<Result<void, ErrorResponse>>;
  /**
   * Start a new run, optionally passing in a number of steps to initialize the
   * run with.
   */
  checkpointNewRun(args: {
    runId: string;
    event: APIStepPayload;
    executionVersion: ExecutionVersion;
    retries: number;
    steps?: OutgoingOp[];
  }): Promise<z.output<typeof checkpointNewRunResponseSchema>>;
  /**
   * Checkpoint steps for a given sync run.
   */
  checkpointSteps(args: {
    runId: string;
    fnId: string;
    appId: string;
    steps: OutgoingOp[];
  }): Promise<void>;
  /**
   * Checkpoint steps for a given async run.
   */
  checkpointStepsAsync(args: {
    runId: string;
    fnId: string;
    queueItemId: string;
    steps: OutgoingOp[];
  }): Promise<void>;
  /**
   * Fetch the output of a completed run using a token.
   *
   * This uses token-based auth (not signing key) and is intended for use by
   * proxy endpoints that fetch results on behalf of users.
   *
   * @param runId - The ID of the run to fetch output for
   * @param token - The token used to authenticate the request
   * @returns The raw Response from the API
   */
  getRunOutput(runId: string, token: string): Promise<Response>;
}
//#endregion
export { InngestApi };
//# sourceMappingURL=api.d.cts.map