{"version":3,"file":"utils.js","sourceRoot":"","sources":["../../../src/common/utils.ts"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;;GAcG;;;AAIH,8CAA0D;AAC1D,mDAA8C;AAE9C,SAAgB,aAAa,CAAC,MAAc;IAC1C,MAAM,WAAW,GAAG,MAAM,CAAC,UAAa,CAAC,CAAC;IAC1C,OAAO,CACL,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,WAAW,GAAG,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAC5E,CAAC;AACJ,CAAC;AALD,sCAKC;AAED,SAAgB,UAAU,CAAC,KAAa;IACtC,MAAM,GAAG,GAAG,MAAM,CAAC,MAAM,CAAC,OAAO,CAAC,EAAE,EAAE,KAAK,CAAC,CAAC,CAAC;IAC9C,MAAM,IAAI,GAAG,MAAM,CAAC,MAAM,CAAC,OAAO,CAAC,EAAE,EAAE,KAAK,IAAI,MAAM,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;IAC7D,OAAO,EAAE,GAAG,EAAE,IAAI,EAAE,CAAC;AACvB,CAAC;AAJD,gCAIC;AAED,SAAgB,gBAAgB,CAAC,MAAc;IAC7C,MAAM,KAAK,GAAG,aAAa,CAAC,MAAM,CAAC,CAAC;IACpC,OAAO,UAAU,CAAC,KAAK,CAAC,CAAC;AAC3B,CAAC;AAHD,4CAGC;AAED,SAAgB,cAAc,CAAC,MAAc;IAC3C,MAAM,KAAK,GAAG,aAAa,CAAC,MAAM,CAAC,CAAC;IACpC,OAAO,KAAK,CAAC,QAAQ,EAAE,CAAC;AAC1B,CAAC;AAHD,wCAGC;AAED,MAAM,eAAe,GACnB,OAAO,MAAM,KAAK,WAAW,CAAC,CAAC,CAAC,cAAc,CAAC,CAAC,CAAC,0BAAmB,CAAC;AAoBvE,SAAS,QAAQ,CAAI,KAAQ;IAC3B,OAAO,KAAK,CAAC;AACf,CAAC;AAED,SAAS,mBAAmB,CAAC,GAAuB;IAClD,IAAI,GAAG,KAAK,SAAS;QAAE,OAAO,SAAS,CAAC;IACxC,OAAO,IAAA,2BAAW,EAAC,GAAG,CAAC,CAAC;AAC1B,CAAC;AAED;;;GAGG;AACU,QAAA,gBAAgB,GAAY;IACvC,YAAY,EAAE,gBAAgB;IAC9B,iBAAiB,EAAE,2BAAW;IAC9B,yBAAyB,EAAE,mBAAmB;IAC9C,gBAAgB,EAAE,QAAQ;CAC3B,CAAC;AAEF;;;GAGG;AACU,QAAA,YAAY,GAAY;IACnC,YAAY,EAAE,eAAe;IAC7B,iBAAiB,EAAE,QAAQ;IAC3B,yBAAyB,EAAE,QAAQ;IACnC,gBAAgB,EAAE,CAAC,KAAiB,EAAU,EAAE;QAC9C,IAAI,OAAO,MAAM,KAAK,WAAW,EAAE;YACjC,OAAO,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC;SAC9C;QAED,gEAAgE;QAChE,oDAAoD;QACpD,MAAM,KAAK,GAAG,IAAI,KAAK,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC;QACtC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;YACrC,KAAK,CAAC,CAAC,CAAC,GAAG,MAAM,CAAC,YAAY,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;SAC1C;QACD,OAAO,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC,CAAC;IAC9B,CAAC;CACF,CAAC","sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { Fixed64, LongBits } from './internal-types';\nimport { HrTime } from '@opentelemetry/api';\nimport { hrTimeToNanoseconds } from '@opentelemetry/core';\nimport { hexToBinary } from './hex-to-binary';\n\nexport function hrTimeToNanos(hrTime: HrTime): bigint {\n  const NANOSECONDS = BigInt(1_000_000_000);\n  return (\n    BigInt(Math.trunc(hrTime[0])) * NANOSECONDS + BigInt(Math.trunc(hrTime[1]))\n  );\n}\n\nexport function toLongBits(value: bigint): LongBits {\n  const low = Number(BigInt.asUintN(32, value));\n  const high = Number(BigInt.asUintN(32, value >> BigInt(32)));\n  return { low, high };\n}\n\nexport function encodeAsLongBits(hrTime: HrTime): LongBits {\n  const nanos = hrTimeToNanos(hrTime);\n  return toLongBits(nanos);\n}\n\nexport function encodeAsString(hrTime: HrTime): string {\n  const nanos = hrTimeToNanos(hrTime);\n  return nanos.toString();\n}\n\nconst encodeTimestamp =\n  typeof BigInt !== 'undefined' ? encodeAsString : hrTimeToNanoseconds;\n\nexport type HrTimeEncodeFunction = (hrTime: HrTime) => Fixed64;\nexport type SpanContextEncodeFunction = (\n  spanContext: string\n) => string | Uint8Array;\nexport type OptionalSpanContextEncodeFunction = (\n  spanContext: string | undefined\n) => string | Uint8Array | undefined;\nexport type Uint8ArrayEncodeFunction = (\n  value: Uint8Array\n) => string | Uint8Array;\n\nexport interface Encoder {\n  encodeHrTime: HrTimeEncodeFunction;\n  encodeSpanContext: SpanContextEncodeFunction;\n  encodeOptionalSpanContext: OptionalSpanContextEncodeFunction;\n  encodeUint8Array: Uint8ArrayEncodeFunction;\n}\n\nfunction identity<T>(value: T): T {\n  return value;\n}\n\nfunction optionalHexToBinary(str: string | undefined): Uint8Array | undefined {\n  if (str === undefined) return undefined;\n  return hexToBinary(str);\n}\n\n/**\n * Encoder for protobuf format.\n * Uses { high, low } timestamps and binary for span/trace IDs, leaves Uint8Array attributes as-is.\n */\nexport const PROTOBUF_ENCODER: Encoder = {\n  encodeHrTime: encodeAsLongBits,\n  encodeSpanContext: hexToBinary,\n  encodeOptionalSpanContext: optionalHexToBinary,\n  encodeUint8Array: identity,\n};\n\n/**\n * Encoder for JSON format.\n * Uses string timestamps, hex for span/trace IDs, and base64 for Uint8Array.\n */\nexport const JSON_ENCODER: Encoder = {\n  encodeHrTime: encodeTimestamp,\n  encodeSpanContext: identity,\n  encodeOptionalSpanContext: identity,\n  encodeUint8Array: (bytes: Uint8Array): string => {\n    if (typeof Buffer !== 'undefined') {\n      return Buffer.from(bytes).toString('base64');\n    }\n\n    // implementation note: not using spread operator and passing to\n    // btoa to avoid stack overflow on large Uint8Arrays\n    const chars = new Array(bytes.length);\n    for (let i = 0; i < bytes.length; i++) {\n      chars[i] = String.fromCharCode(bytes[i]);\n    }\n    return btoa(chars.join(''));\n  },\n};\n"]}